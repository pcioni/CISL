diff --git a/Assets/Scripts/MapVisualization/LoadXML.cs b/Assets/Scripts/MapVisualization/LoadXML.cs
index ed1af5f..ca7ad1f 100644
--- a/Assets/Scripts/MapVisualization/LoadXML.cs
+++ b/Assets/Scripts/MapVisualization/LoadXML.cs
@@ -119,6 +119,9 @@ public class LoadXML : MonoBehaviour {
 			}
 			tn.datevalue = tn.date.ToShortDateString();
 			tn.dateticks = tn.date.Ticks;
+			if (tn.dateticks == 0) {
+				tn.known_date = false;
+			}
 			nodeList.Add(tn);
 			nodeDict[f.data] = tmp_obj;
 
diff --git a/Assets/Scripts/MapVisualization/ViewModeController.cs b/Assets/Scripts/MapVisualization/ViewModeController.cs
index 0d9e0b1..fa21b8d 100644
--- a/Assets/Scripts/MapVisualization/ViewModeController.cs
+++ b/Assets/Scripts/MapVisualization/ViewModeController.cs
@@ -47,6 +47,10 @@ public class ViewModeController : MonoBehaviour {
 		minOrthoSize = mapCam.orthographicSize;
 	}
 
+	enum data_type {
+		LOC,
+		DATE
+	}
 
 	IEnumerator Start() {
 		lx = GetComponent<LoadXML>();
@@ -62,18 +66,33 @@ public class ViewModeController : MonoBehaviour {
 		//find all of the appropriate positions for the current map
 		foreach (timelineNode tn in lx.nodeList) {
 			if (!tn.known_location) {
-				result = find_coordinates(tn);
+				result = reconstruct_data(tn, data_type.LOC);
 				if (!result) {
 					print ("ViewModeController.Start() :: location from outgoing connection data not found for " + tn.node_name + ": " + tn.location);
 					print ("positions.Count: " + positions.Count);
 
-					result = find_coordinates(tn, false, true);
+					result = reconstruct_data(tn, data_type.LOC, false, true);
 					if (!result) {
 						print ("ViewModeController.Start() :: location from incoming connection data not found for " + tn.node_name + ": " + tn.location);
 						print ("positions.Count: " + positions.Count);
 					}
 				}
 			}
+
+			if (!tn.known_date) {
+				result = reconstruct_data(tn, data_type.DATE);
+				if (!result) {
+					print ("ViewModeController.Start() :: date from outgoing connection data not found for " + tn.node_name + ": " + tn.location);
+					print ("positions.Count: " + positions.Count);
+
+					result = reconstruct_data(tn, data_type.DATE, false, true);
+					if (!result) {
+						print ("ViewModeController.Start() :: date from incoming connection data not found for " + tn.node_name + ": " + tn.location);
+						print ("positions.Count: " + positions.Count);
+					}
+				}
+			}
+
 			GameObject dummy = Instantiate(mapNodePrefab) as GameObject;
 			mapNode mn = dummy.GetComponent<mapNode>();
 			mn.master = tn;
@@ -93,13 +112,13 @@ public class ViewModeController : MonoBehaviour {
         {
             if (!tn.known_location && !tn.location_interpolated)
             {
-                result = find_coordinates(tn, true);
+				result = reconstruct_data(tn, data_type.LOC, true);
                 if (!result)
                 {
                     print("ViewModeController.Start() :: location from interpolated ooutgoing connect data not found for " + tn.node_name + ": " + tn.location);
                     print("positions.Count: " + positions.Count);
 
-                    result = find_coordinates(tn, true, true);
+					result = reconstruct_data(tn, data_type.LOC, true, true);
                     if (!result)
                     {
                         print("ViewModeController.Start() :: location from interpolated incoming connection data not found for " + tn.node_name + ": " + tn.location);
@@ -185,16 +204,30 @@ public class ViewModeController : MonoBehaviour {
 
 	private Queue<KeyValuePair<int, timelineNode>> q = new Queue<KeyValuePair<int, timelineNode>>();
 	private List<Vector3> positions = new List<Vector3>();
+	private List<long> tickCounts = new List<long>();
 	private int max_depth = 30;
     private int min_data = 10;
-    private bool find_coordinates(timelineNode start, bool use_interpolated = false, bool use_incoming = false) {
+	private bool reconstruct_data(timelineNode start, data_type dtype, bool use_interpolated = false, bool use_incoming = false) {
 		positions.Clear();
+		tickCounts.Clear();
 		q.Clear();
 		q.Enqueue(new KeyValuePair<int, timelineNode>(0,start));
 		while (q.Count > 0) {
 			KeyValuePair<int, timelineNode> current = q.Dequeue();
-			if ((current.Value.known_location || use_interpolated) && current.Value.location != new Vector2(0,0)) {
-				positions.Add(current.Value.location);
+			switch (dtype) {
+			case data_type.LOC:
+				if ((current.Value.known_location || use_interpolated) && current.Value.location != new Vector2(0,0)) {
+					positions.Add(current.Value.location);
+				}
+				break;
+			case data_type.DATE:
+				if ((current.Value.known_date || use_interpolated) && current.Value.dateticks != 0) {
+					tickCounts.Add(current.Value.dateticks);
+				}
+				break;
+			default:
+				Debug.Log ("ViewModeController.find_coordinates() :: unhandled dataType : " + dtype.ToString());
+				break;
 			}
 			if(current.Key < max_depth) {
                 if (!use_incoming)
@@ -213,18 +246,38 @@ public class ViewModeController : MonoBehaviour {
                 if (positions.Count >= min_data) break; // break if we found enough data
             }
 		}
-		if(positions.Count != 0) {
-			start.location = get_centroid(positions);
-            start.location_interpolated = true;
-            //print("location found for " + start.node_name + ": " + start.location);
-            return true;
-        }
-        else
-        {
-            print("ViewModeController.find_coordinates() :: location not found for " + start.node_name + ": " + start.location);
-            print("positions.Count: " + positions.Count);
-            return false;
-        }
+		switch (dtype) {
+		case data_type.LOC:
+			if(positions.Count != 0) {
+				start.location = get_centroid(positions);
+				start.location_interpolated = true;
+				return true;
+			}
+			else
+			{
+				print("ViewModeController.reconstruct_data() :: location data not found for " + start.node_name + ": " + start.location);
+				print("positions.Count: " + positions.Count);
+				return false;
+			}
+			break;
+		case data_type.DATE:
+			if(tickCounts.Count != 0) {
+				start.dateticks = get_centroid(tickCounts);
+				start.date_interpolated = true;
+				return true;
+			}
+			else
+			{
+				print("ViewModeController.reconstruct_data() :: date data not found; node_name = " + start.node_name + "; dateticks = " + start.dateticks);
+				print("tickCounts.Count: " + tickCounts.Count);
+				return false;
+			}
+			break;
+		default:
+			Debug.Log ("ViewModeController.find_coordinates() :: unhandled dataType : " + dtype.ToString ());
+			return false;
+			break;
+		}
     }
 
 	private Vector3 get_centroid(List<Vector3> positions) {
@@ -242,6 +295,19 @@ public class ViewModeController : MonoBehaviour {
 		return new Vector3(sumx / len, sumy / len, sumz / len);
 	}
 
+	private long get_centroid(List<long> _tickCounts) {
+		long sum = 0;
+		int len = _tickCounts.Count;
+
+		foreach(long t in _tickCounts) {
+			sum += t;
+		}
+
+		return sum / len;
+	}
+
+
+
 	/*
 	public void toggle_mode() {
 		//switch from timeline view to map view and vice versa
diff --git a/Assets/Scripts/MapVisualization/timelineNode.cs b/Assets/Scripts/MapVisualization/timelineNode.cs
index a201ab6..b82d8ca 100644
--- a/Assets/Scripts/MapVisualization/timelineNode.cs
+++ b/Assets/Scripts/MapVisualization/timelineNode.cs
@@ -20,6 +20,8 @@ public class timelineNode : MonoBehaviour
 	public bool mouseOver = false;
 	public bool known_location = false;
     public bool location_interpolated = false;
+	public bool known_date = false;
+	public bool date_interpolated = false;
 	public bool active = false; //Whether this node is active and interactable.
 	public Vector2 location;
 	public Vector3 baseSize;
@@ -85,7 +87,6 @@ public class timelineNode : MonoBehaviour
 		{
 			switch (value)
 			{
-                //TODO: should collision checking / label positioning go here instead?
 				case focusState.HALF:
 					base_color = half_focus_color;
 					ChangeColor(half_focus_color);
